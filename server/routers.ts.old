import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { publicProcedure, router, protectedProcedure } from "./_core/trpc";
import { z } from "zod";
import {
  getUltimaAnalise,
  verificarDuplicidade,
  criarAnalise,
  reportarFraude,
  listarFraudes,
  getFraudesPorCliente,
  getFraudePorAnalise,
  registrarAuditoria,
  listarMetricasAnalises,
  upsertUser,
  listarUsuarios,
  getAnalisePorData,
  getAnalisePorDataETipo,
  registrarAuditoriaAnalise,
  listarAuditorias,
  getStatusAuditoria,
  getAuditoriaPorAnalise,
  getDataCriacaoConta
} from "./db";
import { TRPCError } from "@trpc/server";
import { sanitizeString, sanitizeStringArray, sanitizeIdentifier } from "./_core/sanitize";
import { logger } from "./_core/logger";
import { formatarDataBrasilia, formatarHoraBrasilia, getDataAtualBrasilia, paraISOStringBrasilia } from "./utils/timezone";

const ensureValidDate = (value: string | Date, ctx: z.RefinementCtx) => {
  const parsedDate = value instanceof Date ? value : new Date(value);

  if (Number.isNaN(parsedDate.getTime())) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "Data inválida",
    });
    return;
  }

  if (parsedDate > new Date()) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "Data futura não permitida",
    });
  }
};

const dateField = z.union([
  z.string().trim().min(1, "Data obrigatória"),
  z.date(),
]).superRefine(ensureValidDate);

const optionalDateField = dateField.optional().nullable();

const toDate = (value?: string | Date | null) => {
  if (!value) {
    return undefined;
  }

  if (value instanceof Date) {
    return value;
  }

  // Se for string no formato YYYY-MM-DD, tratar como data local (não UTC)
  // Isso evita problemas de timezone que causam diferença de um dia
  if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
    const [ano, mes, dia] = value.split('-').map(Number);
    // Criar data no timezone local (Brasil)
    const date = new Date(ano, mes - 1, dia);
    return Number.isNaN(date.getTime()) ? undefined : date;
  }

  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? undefined : parsed;
};

const analiseBaseSchema = z.object({
  idCliente: z.string().trim().min(1, "ID do cliente obrigatório"),
  nomeCompleto: z.string().trim().min(2, "Nome do cliente obrigatório"),
  dataAnalise: dateField,
  dataCriacaoConta: optionalDateField,
  tempoAnaliseSegundos: z.number().int().min(0).optional(),
  observacao: z.string().trim().max(1000).optional(),
  fonteConsulta: z.string().trim().min(1).optional(),
  qtdApostas: z.number().int().min(0).optional(),
  retornoApostas: z.number().optional(),
  ganhoPerda: z.number().optional().nullable(),
  auditoriaUsuario: z.boolean().optional(), // TRUE = auditoria marcada, FALSE = não marcada
});

// Schemas for validation
const analisesSchema = z.discriminatedUnion("tipoAnalise", [
  analiseBaseSchema.extend({
    tipoAnalise: z.literal("SAQUE"),
    horarioSaque: z.string().trim().min(1, "Horário do saque obrigatório"),
    valorSaque: z
      .number()
      .gt(0, "Valor do saque deve ser maior que zero"),
    metricaSaque: z.string().trim().min(1, "Métrica do saque obrigatória"),
    categoriaSaque: z.string().trim().min(1, "Categoria do saque obrigatória"),
    jogoEsporteSaque: z.string().trim().min(1, "Informe o jogo ou esporte"),
    financeiro: z.number(),
    valorDeposito: z.undefined().optional(),
    categoriaDeposito: z.undefined().optional(),
    jogoEsporteDepositoApos: z.undefined().optional(),
  }),
  analiseBaseSchema.extend({
    tipoAnalise: z.literal("DEPOSITO"),
    valorDeposito: z
      .number()
      .gt(0, "Valor do depósito deve ser maior que zero"),
    categoriaDeposito: z
      .string()
      .trim()
      .min(1, "Categoria do depósito obrigatória"),
    jogoEsporteDepositoApos: z
      .string()
      .trim()
      .min(1, "Informe o jogo ou esporte após o depósito"),
    financeiro: z.number(),
    valorSaque: z.undefined().optional(),
    horarioSaque: z.undefined().optional(),
    metricaSaque: z.undefined().optional(),
    categoriaSaque: z.undefined().optional(),
    jogoEsporteSaque: z.undefined().optional(),
  }),
]);

const fraudeSchema = z.object({
  idCliente: z.string().min(1),
  dataAnalise: z.string().trim().min(1, "Data da análise obrigatória"),
  descricaoDetalhada: z.string().trim().min(10, "Descrição detalhada obrigatória (mínimo 10 caracteres)"),
  motivoPadrao: z.string().min(1, "Motivo obrigatorio"),
  motivoLivre: z.string().optional(),
});

const auditoriaSchema = z.object({
  idCliente: z.string().min(1),
  motivo: z.string().min(3, "Motivo obrigatorio"),
  tipo: z.enum(["ESPORTIVO", "CASSINO"]),
});

const auditoriaFiltroSchema = z.object({
  tipo: z.enum(["ESPORTIVO", "CASSINO"]).optional(),
  analistaId: z.number().int().optional(),
  dataInicio: z.string().optional(),
  dataFim: z.string().optional(),
});

export const appRouter = router({
  system: systemRouter,

  auth: router({
    me: publicProcedure.query(opts => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return {
        success: true,
      } as const;
    }),
  }),

  // Usuários - administração
  usuarios: router({
    listar: protectedProcedure
      .query(async () => {
        const usuarios = await listarUsuarios();
        return usuarios;
      }),
    
    criar: protectedProcedure
      .input(z.object({ email: z.string().email(), nome: z.string().min(1), role: z.enum(["analista","admin"]).default("analista"), password: z.string().min(6) }))
      .mutation(async ({ input }) => {
        // Sanitizar campos de texto antes de salvar
        // Use email as openId for local users created via admin UI
        const openId = sanitizeIdentifier(input.email);
        await upsertUser({
          password: input.password,
          openId,
          name: sanitizeString(input.nome),
          email: sanitizeIdentifier(input.email),
          loginMethod: 'local',
          role: input.role,
          lastSignedIn: getDataAtualBrasilia(),
        });
        return { success: true };
      }),
  }),

  // Analises procedures
  analises: router({
    getUltimo: protectedProcedure
      .input(z.object({ idCliente: z.string() }))
      .query(async ({ input }) => {
        const ultima = await getUltimaAnalise(input.idCliente);
        return ultima || null;
      }),

    getDataCriacaoConta: protectedProcedure
      .input(z.object({ idCliente: z.string() }))
      .query(async ({ input }) => {
        const dataCriacaoConta = await getDataCriacaoConta(input.idCliente);
        return dataCriacaoConta ? dataCriacaoConta.toString() : null;
      }),

    verificarHoje: protectedProcedure
      .input(z.object({
        idCliente: z.string().min(1),
        dataAnalise: z.string(),
        tipoAnalise: z.enum(["SAQUE", "DEPOSITO"]),
      }))
      .query(async ({ input }) => {
        const duplicado = await verificarDuplicidade(
          input.idCliente, 
          input.dataAnalise,
          input.tipoAnalise
        );
        if (!duplicado) {
          return { duplicado: false, analise: null };
        }

        // Buscar a análise mais recente do mesmo tipo e mesma data
        const analise = await getAnalisePorDataETipo(
          input.idCliente, 
          input.dataAnalise,
          input.tipoAnalise
        );
        return { duplicado: true, analise: analise || null };
      }),

    criar: protectedProcedure
      .input(analisesSchema)
      .mutation(async ({ input, ctx }) => {
        // VALIDAÇÃO ADICIONAL: Garantir que auditoriaData não seja enviado
        // Este campo só é preenchido pelo backend quando registrarAuditoriaAnalise é chamado
        if ('auditoriaData' in input && (input as any).auditoriaData !== undefined) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "auditoriaData não pode ser enviado pelo frontend - é preenchido automaticamente quando auditoria é marcada",
          });
        }
        
        // Check for duplicity
        const normalizedIdCliente = input.idCliente.trim();
        const dataAnaliseDate = toDate(input.dataAnalise);
        if (!dataAnaliseDate) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Data da análise inválida",
          });
        }
        const dataAnaliseStr = paraISOStringBrasilia(dataAnaliseDate);

        // Verificar duplicidade considerando o tipo de análise
        // REGRA: Um cliente pode ter apenas 1 análise de SAQUE e 1 análise de DEPOSITO por dia
        const isDuplicado = await verificarDuplicidade(
          normalizedIdCliente,
          dataAnaliseStr,
          input.tipoAnalise
        );
        if (isDuplicado) {
          // Buscar a análise mais recente para obter a data exata
          const analiseExistente = await getAnalisePorDataETipo(
            normalizedIdCliente,
            dataAnaliseStr,
            input.tipoAnalise
          );
          throw new TRPCError({
            code: "CONFLICT",
            message: "Este usuário já foi analisado na data de hoje.",
          });
        }

        // Converter dataCriacaoConta para string YYYY-MM-DD se fornecida
        // Se for Date, converter para string; se for string, usar diretamente; se undefined, usar null
        let dataCriacaoContaStr: string | null = null;
        if (input.dataCriacaoConta) {
          if (input.dataCriacaoConta instanceof Date) {
            dataCriacaoContaStr = paraISOStringBrasilia(input.dataCriacaoConta);
          } else if (typeof input.dataCriacaoConta === 'string') {
            // Se já for string YYYY-MM-DD, usar diretamente
            dataCriacaoContaStr = input.dataCriacaoConta;
          } else {
            // Tentar converter para Date e depois para string
            const dataCriacaoContaDate = toDate(input.dataCriacaoConta);
            dataCriacaoContaStr = dataCriacaoContaDate ? paraISOStringBrasilia(dataCriacaoContaDate) : null;
          }
        }
        
        // Sanitizar campos de texto antes de salvar
        const observacao = input.observacao ? sanitizeString(input.observacao.trim()) : undefined;
        const fonteConsulta = input.fonteConsulta ? sanitizeString(input.fonteConsulta.trim()) : undefined;

        // Create analysis - sanitizar todos os campos de texto
        // IMPORTANTE: auditoriaData NUNCA deve ser preenchido aqui
        // Só será preenchido quando registrarAuditoriaAnalise for chamado explicitamente
        const analise = {
          idCliente: sanitizeIdentifier(normalizedIdCliente),
          nomeCompleto: sanitizeString(input.nomeCompleto.trim()),
          // Usar string de data diretamente para evitar problemas de timezone
          // A data já vem no formato YYYY-MM-DD do frontend
          dataAnalise: dataAnaliseStr,
          // Usar string de data ou null (nunca Date object)
          dataCriacaoConta: dataCriacaoContaStr,
          tipoAnalise: input.tipoAnalise,
          horarioSaque:
            input.tipoAnalise === "SAQUE"
              ? sanitizeString(input.horarioSaque.trim())
              : undefined,
          valorSaque:
            input.tipoAnalise === "SAQUE"
              ? input.valorSaque.toString()
              : undefined,
          metricaSaque:
            input.tipoAnalise === "SAQUE"
              ? sanitizeString(input.metricaSaque.trim())
              : undefined,
          categoriaSaque:
            input.tipoAnalise === "SAQUE"
              ? sanitizeString(input.categoriaSaque.trim())
              : undefined,
          jogoEsporteSaque:
            input.tipoAnalise === "SAQUE"
              ? sanitizeString(input.jogoEsporteSaque.trim())
              : undefined,
          valorDeposito:
            input.valorDeposito !== undefined
              ? input.valorDeposito.toString()
              : undefined,
          ganhoPerda:
            input.ganhoPerda !== undefined && input.ganhoPerda !== null
              ? input.ganhoPerda.toString()
              : undefined,
          financeiro:
            input.financeiro !== undefined
              ? input.financeiro.toString()
              : undefined,
          categoriaDeposito:
            input.tipoAnalise === "DEPOSITO"
              ? sanitizeString(input.categoriaDeposito.trim())
              : undefined,
          jogoEsporteDepositoApos:
            input.tipoAnalise === "DEPOSITO"
              ? sanitizeString(input.jogoEsporteDepositoApos.trim())
              : undefined,
          tempoAnaliseSegundos: input.tempoAnaliseSegundos,
          qtdApostas: input.qtdApostas,
          retornoApostas:
            input.retornoApostas !== undefined
              ? input.retornoApostas.toString()
              : undefined,
          observacao,
          fonteConsulta: fonteConsulta && fonteConsulta.length > 0 ? fonteConsulta : undefined,
          // ID do analista que está criando a análise
          analistaId: ctx.user?.id,
          // REGRA DE NEGÓCIO: auditoriaUsuario é boolean
          // TRUE = auditoria marcada (gravar auditoriaData com data atual)
          // FALSE ou undefined = não marcada (auditoriaData = NULL)
          auditoriaUsuario: input.auditoriaUsuario ?? false,
          // auditoriaData será preenchido automaticamente no backend se auditoriaUsuario = TRUE
          auditoriaData: undefined,
        };

        await criarAnalise(analise);
        await registrarAuditoria("ANALISE_CRIADA", {
          idCliente: normalizedIdCliente,
          dataAnalise: dataAnaliseStr,
          usuarioId: ctx.user.id,
        }, ctx.user.id);

        return { success: true };
      }),

    finalizar: protectedProcedure
      .input(z.object({ idCliente: z.string(), dataAnalise: z.string() }))
      .mutation(async ({ input, ctx }) => {
        await registrarAuditoria("ANALISE_FINALIZADA", {
          idCliente: input.idCliente,
          dataAnalise: input.dataAnalise,
          usuarioId: ctx.user.id,
        }, ctx.user.id);

        return { success: true, status: "APROVADO" };
      })
  }),

  auditorias: router({
    registrar: protectedProcedure
      .input(auditoriaSchema)
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user?.id) {
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }

        // Sanitizar campos de texto antes de salvar
        await registrarAuditoriaAnalise({
          idCliente: sanitizeIdentifier(input.idCliente),
          motivo: sanitizeString(input.motivo),
          tipo: input.tipo,
          analistaId: ctx.user.id,
        });

        await registrarAuditoria("AUDITORIA_REGISTRADA", {
          idCliente: input.idCliente,
          motivo: input.motivo,
          tipo: input.tipo,
          usuarioId: ctx.user.id,
        }, ctx.user.id);

        return { success: true };
      }),

    listar: protectedProcedure
      .input(auditoriaFiltroSchema.optional())
      .query(async ({ input }) => {
        try {
          const auditorias = await listarAuditorias(input ?? {});
          return auditorias;
        } catch (error) {
          logger.logError(
            "Erro ao listar auditorias",
            error instanceof Error ? error : new Error(String(error)),
            undefined,
            { input }
          );
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Erro ao buscar auditorias",
          });
        }
      }),

    status: protectedProcedure
      .input(z.object({ idCliente: z.string().min(1) }))
      .query(async ({ input }) => {
        try {
          return await getStatusAuditoria(input.idCliente);
        } catch (error) {
          logger.logError(
            "Erro ao buscar status de auditoria",
            error instanceof Error ? error : new Error(String(error)),
            undefined,
            { idCliente: input.idCliente }
          );
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Erro ao buscar status de auditoria",
          });
        }
      }),

    porAnalise: protectedProcedure
      .input(z.object({ 
        idCliente: z.string().min(1),
        dataAnalise: z.string().min(1),
        tipoAnalise: z.enum(["SAQUE", "DEPOSITO"]).optional(),
      }))
      .query(async ({ input }) => {
        const auditoria = await getAuditoriaPorAnalise(
          input.idCliente, 
          input.dataAnalise,
          input.tipoAnalise
        );
        return auditoria;
      }),
  }),

  // Metricas procedures
  metricas: router({
    getAnalises: protectedProcedure
      .input(z.object({
        analista_id: z.number().optional(),
        data_inicio: z.date().optional(),
        data_fim: z.date().optional(),
        tipo_analise: z.enum(["SAQUE", "DEPOSITO"]).optional(),
        id_cliente: z.string().optional(),
      }))
      .query(async ({ input }) => {
        return await listarMetricasAnalises(input);
      }),
  }),

  // Fraudes procedures
  fraudes: router({
    reportar: protectedProcedure
      .input(fraudeSchema)
      .mutation(async ({ input, ctx }) => {
        // Sanitizar campos de texto antes de salvar
        const fraude = {
          idCliente: sanitizeIdentifier(input.idCliente),
          dataAnalise: input.dataAnalise, // Data da análise quando a fraude foi reportada
          descricaoDetalhada: sanitizeString(input.descricaoDetalhada),
          motivoPadrao: sanitizeString(input.motivoPadrao),
          motivoLivre: input.motivoLivre ? sanitizeString(input.motivoLivre) : undefined,
          analistaId: ctx.user.id,
          dataRegistro: getDataAtualBrasilia(),
        };

        await reportarFraude(fraude);
        await registrarAuditoria("FRAUDE_REPORTADA", {
          idCliente: input.idCliente,
          motivo: input.motivoPadrao,
          usuarioId: ctx.user.id,
        }, ctx.user.id);

        return { success: true };
      }),

    status: protectedProcedure
      .input(z.object({ idCliente: z.string().min(1) }))
      .query(async ({ input }) => {
        const fraudesCliente = await getFraudesPorCliente(input.idCliente);
        return {
          temFraude: fraudesCliente.length > 0,
          fraudes: fraudesCliente,
        };
      }),

    porAnalise: protectedProcedure
      .input(z.object({ 
        idCliente: z.string().min(1),
        dataAnalise: z.string().min(1),
      }))
      .query(async ({ input }) => {
        const fraude = await getFraudePorAnalise(input.idCliente, input.dataAnalise);
        return fraude;
      }),

    listar: protectedProcedure
      .input(z.object({ 
        limit: z.number().default(50),
        offset: z.number().default(0),
      }))
      .query(async ({ input }) => {
        const fraudes = await listarFraudes(input.limit, input.offset);
        return fraudes;
      }),
  }),
});

export type AppRouter = typeof appRouter;

